<head>
  <title>Noobs Playground</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap');
  </style>
  <link rel='stylesheet' href='style.css'>
</head>
<body>
  <div class='header'>
    <h1>Noobs Playground</h1>
    <a href='games.html'><h3>Games</h3></a
    <div class='right'>
      <a href='credits.html'><h3>Credits</h3></a>
      <a href='https://discord.com'><h3>Discord</h3></a>
    </div>
  </div>
  <iframe src='https://ultraviolet.segso.net/' id='browser' scrolling='yes'>Unable To Load</iframe>
  <canvas id='honeycomb'></canvas>
  <script>
    const canvas = document.getElementById('honeycomb');
    const ctx = canvas.getContext('2d');
    
    let w, h;
    const hexagons = [];
    const hexRadius = 40;
    const hexHeight = Math.sqrt(3) * hexRadius;
    const hexWidth = 2 * hexRadius;
    
    // Renamed function to reflect that it handles both resize and redraw logic
    function resizeAndRedraw() {
        // Set canvas width to viewport width
        w = canvas.width = window.innerWidth;
        
        // Use the full body height for the canvas drawing area
        // This makes the pattern cover the entire scrollable content
        const newHeight = document.body.offsetHeight;
        
        // Only redraw if the height has changed significantly, or if h is 0 (initial run)
        if (h !== newHeight) {
            h = canvas.height = newHeight;
            hexagons.length = 0; // Clear old hexagons
            createHexagons();
        }
    }
    
    function drawHexagon(x, y, radius, brightness, glow) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = x + radius * Math.cos(angle);
            const hy = y + radius * Math.sin(angle);
            if (i === 0) ctx.moveTo(hx, hy);
            else ctx.lineTo(hx, hy);
        }
        ctx.closePath();
        
        // Glow effect
        if (glow > 0) {
            ctx.shadowBlur = 20 * glow;
            ctx.shadowColor = `rgba(255, 255, 255, ${glow * 0.8})`;
        }
        
        // Fill
        ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, 0.05)`;
        ctx.fill();
        
        // Stroke with varying brightness
        ctx.shadowBlur = 0;
        ctx.strokeStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${0.3 + glow * 0.5})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }
    
    function createHexagons() {
        hexagons.length = 0;
        // The rows calculation now uses the full document height 'h'
        const cols = Math.ceil(w / (hexWidth * 0.75)) + 2;
        const rows = Math.ceil(h / hexHeight) + 2;
        
        for (let row = -1; row < rows; row++) {
            for (let col = -1; col < cols; col++) {
                const x = col * hexWidth * 0.75;
                const y = row * hexHeight + (col % 2 === 1 ? hexHeight / 2 : 0);
                
                hexagons.push({
                    x,
                    y,
                    brightness: 80 + Math.random() * 100,
                    glowSpeed: 0.005 + Math.random() * 0.01,
                    glowPhase: Math.random() * Math.PI * 2,
                    glow: 0
                });
            }
        }
    }
    
    function animate() {
        // Clear the entire canvas drawing area
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, w, h);
        
        const time = Date.now() * 0.001;
        
        hexagons.forEach(hex => {
            hex.glow = (Math.sin(time * hex.glowSpeed + hex.glowPhase) + 1) / 2;
            drawHexagon(hex.x, hex.y, hexRadius, hex.brightness, hex.glow);
        });
        
        requestAnimationFrame(animate);
    }

    // --- Event Listeners for Dynamic Redrawing ---

    // 1. Initial call after all content is loaded
    window.addEventListener('load', resizeAndRedraw);

    // 2. Window resize event
    window.addEventListener('resize', resizeAndRedraw);

    // 3. MutationObserver to handle dynamic content (e.g., infinite scroll)
    const observer = new MutationObserver((mutationsList, observer) => {
        // Only redraw if the measured height is actually greater than the current canvas height
        if (document.body.offsetHeight > h) {
            resizeAndRedraw();
        }
    });

    // Start observing the body for changes to content
    observer.observe(document.body, { childList: true, subtree: true, attributes: true });

    // Start the animation loop
    animate();
  </script>
</body>
